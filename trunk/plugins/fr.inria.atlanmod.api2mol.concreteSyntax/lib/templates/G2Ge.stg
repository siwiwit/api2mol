group G2Ge;

debug() ::= "holaquetalestas"

addAfter(assign, list) ::= "<assign> <list>"

addBefore(assign, list) ::= "<list> <assign>"

normalRule(assign) ::= "<assign>"

rewriteRule(assign, list) ::= <<
<assign> 
	{
	<list>
	}
>>

insertId(id, rule) ::= " <id>=<rule>"

insertIdAggregation(id, rule) ::= " <id>+=<rule>"

insertGrammarOutput(before, after) ::= <<
<before> 

// Autogenerated options
options {
	output=template;
}

<after>
>>

insertOutputIntoOptions(before, after) ::= <<
<before>
	output=template;
<after>
>>

insertGrammarImport(rule) ::= <<

// Autogenerated import
@header {
	import gts.modernization.model.CST.impl.*;
	import gts.modernization.model.CST.*;
	import java.util.Iterator;
}

// Rules
<rule>
>>

insertImportIntoHeader(before, after) ::= <<
<before>
	// Autogenerated Imports
	import gts.modernization.model.CST.impl.*;
	import gts.modernization.model.CST.*;
	import java.util.Iterator;
<after>
>>

insertReturnIntoGrammarRuleReturn(assign) ::= <<
[<assign>, List returnList]
>>

insertRuleReturn(before, after) ::= <<
<before> returns [Node returnNode] 
<after>
>>

createMainRuleHeader(ruleName) ::= <<
	// Create return CST Node
	Node <ruleName>ReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
	<ruleName>ReturnNode.setKind("<ruleName>");

>>

createRuleHeader(ruleName) ::= <<
	// Create return CST Node
	Node <ruleName>ReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
	<ruleName>ReturnNode.setKind("<ruleName>");

>>

createMainRuleFooter(ruleName) ::= <<
	// Returns the Node with CST Leaves/Nodes
	$<ruleName>.returnNode = <ruleName>ReturnNode;
>>

createRuleFooter(ruleName) ::= <<
	// Returns the Node with CST Leaves/Nodes
	$<ruleName>.returnNode = <ruleName>ReturnNode;
>>

createNormalLeaf(ruleName, id, kind, pos, line) ::= <<
    // Create a CST Leaf
	if($<id> != null) {
		Leaf <id>Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("<kind>", $<id>.text, <id>.getCharPositionInLine(), <id>.getLine());
		<ruleName>ReturnNode.getChildren().add(<id>Leaf);
	}

>>

createIslandNode(ruleName, id, islandGrammarName) ::= <<
	// Calls to the island parser
	ANTLRStringStream ass = new ANTLRStringStream($<id>.text);
	<islandGrammarName>Lexer ilexer = new <islandGrammarName>Lexer(ass);
	CommonTokenStream cts = new CommonTokenStream(ilexer);
	<islandGrammarName>Parser iparser = new <islandGrammarName>Parser(cts);
	<islandGrammarName>Parser.mainRule_return r = iparser.mainRule();
	Node return<islandGrammarName>Node = r.returnNode;
	
	Node <islandGrammarName>Node = CSTFactoryImpl.eINSTANCE.createNode();
	<islandGrammarName>Node.setKind("<id>");
		
	if(return<islandGrammarName>Node != null) {
	   	<islandGrammarName>Node.getChildren().add(return<islandGrammarName>Node);
	}
		
	<ruleName>ReturnNode.getChildren().add(<islandGrammarName>Node);
>>

createTokenLeaf(ruleName, id, kind, pos, line) ::= <<
    // Create a Token CST Leaf	
    if($<id> != null) {
		Leaf <id>Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $<id>.text, <id>.getCharPositionInLine(), <id>.getLine());
 		<ruleName>ReturnNode.getChildren().add(<id>Leaf);
 	}

>>

createNode(grammar, ruleName, id, kind, realKind) ::= <<
    // Create a CST Node
	if($<id> != null) {
        for(Iterator it = $<id>.iterator(); it.hasNext(); )  { 
            <grammar>Parser.<realKind>_return r = (<grammar>Parser.<realKind>_return) it.next(); 
            if(r != null && r.returnNode != null) {
            	r.returnNode.setKind("<kind>");
            	<ruleName>ReturnNode.getChildren().add(r.returnNode);
            } 
        }
    }

>>

reuseNode(grammar, ruleName, id, kind) ::= <<
    // Reuse <kind>Node	
	if($<id> != null) {
        for(Iterator it = $<id>.iterator(); it.hasNext(); )  { 
            <grammar>Parser.<kind>_return r = (<grammar>Parser.<kind>_return) it.next(); 
            <kind>Node.getChildren().add(r.returnNode); 
        }
    }

>>

createNode4LeafAggregation(grammar, ruleName, id, pos, line) ::= <<
    // Create a special CST Node for terminal <id> aggregation
	if($<id> != null) {
		Node <id>Node = CSTFactoryImpl.eINSTANCE.createNode();
		<id>Node.setKind("<id>");
		// Iterate over field
		int count = 0;
        for(Iterator it = $<id>.iterator(); it.hasNext(); )  { 
	        Token t = (Token) it.next(); 
	        Leaf <id>Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("<id>" + count++, t.getText(), <pos>, <line>);
            <id>Node.getChildren().add(<id>Leaf); 
        }
		<ruleName>ReturnNode.getChildren().add(<id>Node);
    }

>>

createPreClosure(control)::= <<

	// Create a special CST Node for terminal <control> aggregation
	if($<control> != null) {
    for(int pos = 0; pos \< $<control>.size(); pos++ )  { 

>>

createTerminalExtractor(grammar, ruleName, id, kind)::= <<
	// Terminal extractor
    if($<id> != null) {
	    Token t = (Token) $<id>.get(pos); 
	    Leaf <id>Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("<kind>", t.getText(), t.getCharPositionInLine(), t.getLine());
		<ruleName>ReturnNode.getChildren().add(<id>Leaf);
	}

>>

createNoTerminalExtractor(grammar, ruleName, id, kind, realKind)::= <<
	// No Terminal extractor
    if($<id> != null) {		
    	<grammar>Parser.<realKind>_return r = (<grammar>Parser.<realKind>_return) $<id>.get(pos); 
    	if(r != null && r.returnNode != null) {
        	r.returnNode.setKind("<kind>");
    		<ruleName>ReturnNode.getChildren().add(r.returnNode);
    	} 
	}

>>

createPostClosure()::= <<
	}
	}


>>

createPrePrefix(control)::= <<

	// Create a special CST Node for <control> prefix
	if($<control> != null) {
	Node <control>ReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
	<control>ReturnNode.setKind("<control>");

>>

createPostPrefix(ruleName, control)::= <<
	<ruleName>ReturnNode.getChildren().add(<control>ReturnNode)
	}


>>
