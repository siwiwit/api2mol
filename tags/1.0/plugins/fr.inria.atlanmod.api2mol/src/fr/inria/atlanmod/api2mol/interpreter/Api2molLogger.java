/*******************************************************************************
 * Copyright (c) 2008, 2012
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Javier Canovas (javier.canovas@inria.fr) 
 *******************************************************************************/

package fr.inria.atlanmod.api2mol.interpreter;

import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;

import org.eclipse.emf.common.util.URI;
import org.eclipse.gmt.modisco.core.modeling.Model;
import org.eclipse.gmt.modisco.core.modeling.ModelElement;
import org.eclipse.gmt.modisco.core.modeling.ReferenceModel;
import org.eclipse.gmt.modisco.core.projectors.ProjectorActualParameter;
import org.eclipse.gmt.modisco.modelhandler.emf.EMFModelHandler;
import org.eclipse.gmt.modisco.modelhandler.emf.modeling.EMFModel;
import org.eclipse.gmt.modisco.modelhandler.emf.modeling.EMFReferenceModel;
import org.eclipse.gmt.modisco.modelhandler.emf.projectors.EMFExtractor;
import org.eclipse.gmt.modisco.modelhandler.emf.projectors.EMFInjector;

/**
 * This class allows us to register all the messages generated by the tool as a logger.
 * It has been implemented as a singleton whose messages are written into a log file located in
 * DEFAULT_PATH static variable. This variable can be modified for changing the target path.
 * The class also supports the use of indentation. For this purpose, you have to use the indDeep and
 * decDeep methods, which are in charge of indenting the text which is received.
 * 
 * @author jlcanovas
 *
 */
public class Api2molLogger {
	public enum ProcessType { INJECT, EXTRACT };
	public enum StepType { PROPERTY, NEW, MULTIPLE, ENUM };
	public static String LOG_METAMODEL_PATH = "./log/log.ecore";
	public static String LOG_MODEL_PATH = "./log/logModel.ecore.xmi";

	public static String DEFAULT_PATH = "log.txt";
	public static String TAB_SPACE = "  ";

	private static Api2molLogger instance;
	private PrintStream log;
	private int deep = 0;
	private static boolean quiet = false;

	// model log
	private Model logModel;
	private ReferenceModel logMetamodel;
	private ModelElement lastProcess;
	private ModelElement lastStep;

	private Api2molLogger(String path) {
		if(!quiet) {
			try {
				log = new PrintStream(path);
				log.println("Api2MoL Logger\n");
				log.println("Api2MoL Projector version " + Api2molProjector.VERSION + "\n\n");	
				log.flush();
			} catch (Exception e) {
				System.err.println("Error creating the log file");
			}
		}
		
		// Setting the error output
		System.setErr(log);

		// creating the log model
		Map<String, ProjectorActualParameter<?>> params = new HashMap<String, ProjectorActualParameter<?>>();
		params.put("URI", new ProjectorActualParameter<URI>(URI.createFileURI(LOG_METAMODEL_PATH)));
		logMetamodel = (ReferenceModel) (new EMFModelHandler()).loadModel(EMFReferenceModel.getMetametamodel(), EMFInjector.getInstance(), params);
		logModel = (new EMFModelHandler()).createModel(logMetamodel);
	}

	// Methods for log model

	public void createProcess(ProcessType type) {
		switch(type) {
		case INJECT:
			ModelElement iprocess = logModel.createModelElement(logMetamodel.getReferenceModelElementByName("log::Process"));
			iprocess.set("type", "INJECT");
			lastProcess = iprocess;
			lastStep = iprocess;
			break;
		case EXTRACT:
			ModelElement eprocess = logModel.createModelElement(logMetamodel.getReferenceModelElementByName("log::Process"));
			eprocess.set("type", "EXTRACT");
			lastProcess = eprocess;
			lastStep = eprocess;
			break;
		}
	}

	public void createMappingStep(ModelElement mappingRule, String concreteMetaclass, boolean isInferred) {
		ModelElement step = logModel.createModelElement(logMetamodel.getReferenceModelElementByName("log::MappingStep"));
		step.set("mappingRule", mappingRule);
		step.set("concreteMetaclass", concreteMetaclass);
		step.set("metaclassInferred", isInferred);
		lastStep.add("steps", step);
	}

	public void createPropertySectionStep(ModelElement section, String concreteProperty, String concreteStatement) {
		ModelElement step = logModel.createModelElement(logMetamodel.getReferenceModelElementByName("log::PropertySectionStep"));
		step.set("section", section);
		step.set("concreteProperty", concreteProperty);
		step.set("concreteStatement", concreteStatement);
		lastStep.add("steps", step);
		lastStep = step;
	}

	public void createDefaultMetaclassStep(ModelElement section, String value) {
		ModelElement step = logModel.createModelElement(logMetamodel.getReferenceModelElementByName("log::DefaultMetaclassStep"));
		step.set("section", section);
		step.set("concreteValue", value);
		lastStep.add("steps", step);
	}

	public void createInjectionElement(String concreteInstanceClass, boolean cached) {
		ModelElement step = logModel.createModelElement(logMetamodel.getReferenceModelElementByName("log::InjectionElement"));
		step.set("concreteInstanceClass", concreteInstanceClass);
		step.set("cached", cached);
		lastStep.add("steps", step);
		lastStep = step;
	}

	public void createMessage(String value) {
		ModelElement step = logModel.createModelElement(logMetamodel.getReferenceModelElementByName("log::Message"));
		step.set("value", value);
		lastStep.add("steps", step);
	}

	public void saveModel() {
		Map<String, ProjectorActualParameter<?>> params = new HashMap<String, ProjectorActualParameter<?>>();
		params.put("URI", new ProjectorActualParameter<URI>(URI.createFileURI(LOG_MODEL_PATH)));
		(new EMFModelHandler()).saveModel((EMFModel) logModel, EMFExtractor.getInstance(), params);
	}

	/**
	 * Returns the only instance of Api2molLogger
	 * 
	 * @return
	 */
	public static Api2molLogger getInstance() {
		if(instance == null) instance = new Api2molLogger(DEFAULT_PATH);
		return instance;
	}

	/**
	 * Prints a message in a new line. It also includes the correct indentation
	 * 
	 * @param msg The message to be written
	 */
	public void print(String msg) {
		if(!quiet) {
			try {
				log.append("\n" + buildIndentation() + msg);
				log.flush();
			} catch(Exception e) {
				System.err.println("Error printing in the log file");
				e.printStackTrace();
			}
		}
	}


	/**
	 * Builds a new indentation space
	 * 
	 * @return
	 */
	private String buildIndentation() {
		String sol = "";
		for(int i = 0; i < deep; i++) {
			sol = sol + TAB_SPACE;
		}
		return sol;
	}

	/**
	 * Appends a message (it does not neihter includes a new line nor identations)
	 * 
	 * @return
	 */
	public void append(String msg) {
		if(!quiet) {
			try {
				log.append(msg);
				log.flush();
			} catch(Exception e) {
				System.err.println("Error printing in the log file");
				e.printStackTrace();
			}
		}
	}

	public void finalizeLog() {
		if(!quiet) {
			try {
				log.close();
			} catch (Exception e) {
				System.err.println("Error closing the log file");
				e.printStackTrace();
			}
		}

	}

	public void incDeep() {
		this.deep++;
	}

	public void decDeep() {
		this.deep--;
		this.upToFather();
	}

	public void upToFather() {
		if(lastStep != null) {
			if(!lastStep.isKindOf(logMetamodel.getReferenceModelElementByName("log::Process"))) {
				ModelElement father = lastStep.getContainer();
				if(father != null) lastStep = father;
			}
		}
	}

	public static boolean isQuiet() {
		return quiet;
	}

	public static void setQuiet(boolean quiet) {
		Api2molLogger.quiet = quiet;
	}
}
